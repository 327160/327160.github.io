<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>H5概述</title>
    <url>/2022/08/15/00_html5%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="Html5"><a href="#Html5" class="headerlink" title="Html5"></a>Html5</h2><p>​	HTML5 是定义 HTML 标准的最新的版本。 该术语表示两个不同的概念：<br>​		它是一个新版本的HTML语言，具有新的元素，属性和行为，<br>​		它有更大的技术集，允许更多样化和强大的网站和应用程序。<br>​				这个集合有时称为HTML5和朋友，通常缩写为HTML5。<br>​	</p>
<pre><code>    HTML5     约等于     HTML + CSS + JS
</code></pre>
<h3 id="Html5优势"><a href="#Html5优势" class="headerlink" title="Html5优势"></a>Html5优势</h3><p>​	跨平台:唯一一个通吃PC MAC Iphone Android等主流平台的跨平台语言<br>​	快速迭代<br>​	降低成本<br>​	导流入口多<br>​	分发效率高<br>​	</p>
<p>​		</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5_canvas基本用法</title>
    <url>/2022/08/17/01_canvas(%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95)/</url>
    <content><![CDATA[<pre><code>1.什么是canvas(画布)
        &lt;canvas&gt; 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形
    例如，它可以用于绘制图形，创建动画。&lt;canvas&gt; 最早由Apple引入WebKit
    我们可以使用&lt;canvas&gt;标签来定义一个canvas元素
        -----&gt;使用&lt;canvas&gt;标签时，建议要成对出现，不要使用闭合的形式。
        -----&gt;canvas元素默认具有高宽
                    width：  300px
                    height：150px
    
2.替换内容
        &lt;canvas&gt;很容易定义一些替代内容。由于某些较老的浏览器（尤其是IE9之前的IE浏览器）
    不支持HTML元素"canvas"，
    但在这些浏览器上你应该要给用户展示些替代内容。
    这非常简单：我们只需要在&lt;canvas&gt;标签中提供替换内容就可以。
        ---&gt;支持&lt;canvas&gt;的浏览器将会忽略在容器中包含的内容，并且只是正常渲染canvas。
        ---&gt;不支持&lt;canvas&gt;的浏览器会显示代替内容
        
3.canvas标签的两个属性
        &lt;canvas&gt; 看起来和 &lt;img&gt; 元素很相像，唯一的不同就是它并没有 src 和 alt 属性。
    实际上，&lt;canvas&gt; 标签只有两个属性—— width和height。这些都是可选的。
    当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。
    
    画布的高宽
        html属性设置width height时只影响画布本身不影画布内容
        css属性设置width height时不但会影响画布本身的高宽，
                    还会使画布中的内容等比例缩放（缩放参照于画布默认的尺寸）
    
4.渲染上下文
        &lt;canvas&gt; 元素只是创造了一个固定大小的画布，要想在它上面去绘制内容，
    我们需要找到它的渲染上下文
        &lt;canvas&gt; 元素有一个叫做 getContext() 的方法，这个方法是用来获得渲染上下文和它的绘画功能。
    getContext()只有一个参数，上下文的格式
        -----&gt;获取方式
              var canvas = document.getElementById('box');
              var ctx = canvas.getContext('2d');
              
        -----&gt;检查支持性
              var canvas = document.getElementById('tutorial');
              if (canvas.getContext){
                    var ctx = canvas.getContext('2d');
                } 
</code></pre>
<p>​	<br>​		</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>DOCTYPE和浏览器渲染模式</title>
    <url>/2022/08/20/02_DOCTYPE/</url>
    <content><![CDATA[<p>H5<br>    1.DOCTYPE和浏览器渲染模式<br>        DOCTYPE，或者称为 Document Type Declaration（文档类型声明，缩写 DTD）<br>        通常情况下，DOCTYPE 位于一个 HTML 文档的最前面的位置，位于根元素 HTML 的起始标签之前。<br>        因为浏览器必须在解析 HTML 文档正文之前就确定当前文档的类型，以决定其需要采用的渲染模式，<br>        不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析</p>
<pre><code>    到目前为止，各浏览器主要包含了三种模式。在 HTML5 草案中，更加明确的规定了模式的定义：
      	 传统名称	    				  		HTML5 草案名称				document.compatMode 返回值
    standards mode(strict mode) 			no-quirks mode				CSS1Compat
    almost standards mode					limited-quirks mode			CSS1Compat
    quirks mode								quirks mode					BackCompat
</code></pre>
<p>​	<br>​		document.compatMode<br>​			 document.compatMode 属性最初由微软在 IE 中创造出来，这是一个只读的属性，返回一个字符串，<br>​			 只可能存在两种返回值：<br>​				BackCompat：标准兼容模式未开启（怪异模式）<br>​				CSS1Compat：标准兼容模式已开启（标准模式）<br>​	<br>        在现代主流浏览器中，其实怪异模式的渲染和标准与几乎标准间没有太大的差别（ie9+ 谷歌 火狐 …）<br>        ie5.5之前都是ie自己的渲染模式，怪异模式<br>        ie6才开始慢慢支持标准，标准模式，在ie6 中怪异和标准模式的区别最大<br>        ie7 8 9都是基于标准模式升级的，他们理论上存在怪异模式</p>
<pre><code>    HTML5提供的&lt;DOCTYPE html&gt;是标准模式，向后兼容的,等同于开启了标准模式，
    那么浏览器就得老老实实的按照W3C的 标准解析渲染页面
    一个不含任何 DOCTYPE 的网页将会以 怪异(quirks) 模式渲染。
</code></pre>
<p>​		<br>​		<br>​		<br>​		<br>​	2.DTD<br>​		<br>​			当 doctype 信息如上时，表明该页面是遵守了 HTML5 规范的，浏览器会选择 Standards Mode，这种 doctype 是最推荐的一种，<br>​		我们平时设计页面都应该加上这一个 doctype。<br>​			HTML5 不基于 SGML,所以不需要引用 DTD,浏览器内部本身有对标签进行解析渲染验证的模块<br>​		<br>        <br>        当 doctype 如上时，浏览器同样会选择 Standards Mode，虽然和第一种 doctype 有一些区别，但是几乎可以认为是一样的。</p>
<pre><code>    &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
    当 doctype 如上时，浏览器会选择 Almost Standards Mode，渲染时和标准会有一些区别

    当 doctype 缺失的时候，浏览器会选择 Quirks Mode，这是非常不推荐的方式，
    当 doctype上面有注释，标签或者空行时，某些浏览器都会认为该页面不具有doctype。
    我们应该尽量避免 Quirks Mode，这对一个 web 应用是非常不利的地方。
</code></pre>
<p>​	<br>​	<br>​	<br>​		<br>​	4.每种doctype在浏览器中对应的渲染模式<br>​		<a href="https://en.wikipedia.org/wiki/Quirks_mode">https://en.wikipedia.org/wiki/Quirks_mode</a></p>
<p>​				<br>​	<br>​	</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5音频视频标签</title>
    <url>/2022/08/16/01_%E9%9F%B3%E9%A2%91&amp;%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<pre><code>大家都有在网页中浏览视频的经历，但在Html5之前，对视频乃至音频都还没有一个标准
因此在网页中看到的视频，都是通过第三插件的方式嵌入的，可能是QuickTime，也可能是
RealPlayer 或者 Flash。浏览器很好的整合了这些插件，你完全意识不到它们的存在

在介绍Html5中的音视频标签前，我们需要了解一些概念

1. 容器
    大多数人会认为视频文件就是 .avi .mp4,但事实上 avi和mp4仅仅是容器的格式，
    它只决定怎么将视频存储起来，而不关系存储的内容。有点类似于.zip

    不管是音频文件或视频文件，实际上都只是一个容器文件。这点类似于压缩了一组文件的ZIP文件
    视频文件（视频容器）包含了音频轨道、视频轨道和其他一些元数据。
    视频播放的时候，音频轨道和视频轨道是绑定在一起的。
    元数据包含了视频的封面、标题、子标题、字幕等相关信息。
    
    主流的视频文件格式(容器格式)					主流的音频文件格式
        MPEG-4:	     通常以.mp4为扩展名				MPEG-3  	.mp3
        Flash视频: 	 通常以.flv为扩展名				Acc音频    .acc
        Ogg:	    		 通常以.ogv为扩展名		Ogg音频	.ogg
        WebM:	    	 通常以.webm为扩展名
        音频视频交错: 通常以.avi为扩展名
                        
2. 编解码器
    音频和视频编码/解码是一组算法，用来对一段特定音频或视频进行解码和编码，以便
    音频和视频能够播放。原始的媒体文件体积非常巨大，如果不对其进行编码，那么数据量是
    非常惊人的，在互联网上传播则要耗费无法忍受的时间；如果不对其进行解码，就无法将编
    码后的数据重组为原始的媒体数据
    
          视频编解码器			   音频编解码器			 
            H.264			    			AAC
            VP8								MPEG-3
            Ogg Theora					Ogg Vorbis
        
        H.264： 别名 MPEG-4的第十部分,由MPEG研发并于2003年标准化
                              它的目的支持一切设备，无论是低带宽低cpu，还是高带宽高cpu 或者是两者之间。
                              要做到这一点，H.264标准被分成不同的几种配置。高配置使用了更多特性，
                              这会导致在解码过程中更加消耗CPU，但视频文件本身会更小，视频效果也更好 
                              
                            苹果iphone手机		基本配置(BaseLine)
                            正常的电视机支持        基本配置(BaseLine) 和 主配置(Main)两种
                            正常的电脑支持  	        基本配置(BaseLine) 和 主配置(Main) 高级配置(high)三种
</code></pre>
<p>​			<br>        当然有一些编解码器受专利的保护，有一些则是免费的，例如Ogg的Vorbis音频编解码器。<br>        Ogg的Theora视频编解码器也是可以免费使用的。而想使用H.264的话就需要支付相关的费用了</p>
<pre><code>    现在的视频编解码器会使用各种技巧减少从一帧到另一帧过程中传递的信息数量，它们不会存储每一帧的
    所有信息，而只是存储两帧之间的差异信息。
    编码器也分有损和无损，无损视频文件一般太大，在网页中没有优势，所以我们重点研究有损编解码器。
    有损编解码器中，信息在编码过程中丢失是无法避免的，反复的对视频编码会导致其画面不均匀。
    
3.浏览器对于容器和编解码器支持的情况
    Browser						MP4(H.264 + AAC)	WebM(VP8 + Vorbis )		Ogg(Theora + Vorbis)
    Internet Explorer 9				YES						NO					NO
    Firefox 4.0						NO						YES					YES
    Google Chrome 					YES						YES					YES
    Apple Safari 5					YES						NO					NO
    Opera 10.6						NO						YES					YES
    
    http://www.html5videoplayer.net/html5video/html5-video-browser-compatibility/
    目前还没有一种编解码和容器的组合能应用于所有的浏览器中！！！
    
4.处理视频的一个流程
    1.制作一个Ogg容器中使用Theora视频和Vorbis音频的版本
    2.制作另外一个版本，使用WebM视频容器（VP8 + Vorbis）
    3.再制作一个版本，使用MP4视频容器，并使用H.264基本配置的视频和ACC低配的音频
    4.链接上面3个文件到同一个video元素，并向后兼容基于Flash的视频播放器	
</code></pre>
<p>​		<br>    5. 格式转化<br>        用 FFmpeg 制作MP4 视频<br>            ffmpeg -i test.mp4 -c:v libx264 -s 1280x720 -b:v 1500k -profile:v high -level 3.1 -c:a aac -ac 2 -b:a 160k -movflags faststart OUTPUT.mp4</p>
<pre><code>    用 FFmpeg 制作 WebM 视频
        ffmpeg -i test.mp4 -c:v libvpx -s 1280x720 -b:v 1500k -c:a libvorbis -ac 2 -b:a 160k OUTPUT.webm
    
    FFmpeg 制作 Ogg 视频
        ffmpeg -i test.mp4 -c:v libtheora -s 1280x720 -b:v 1500k -c:a libvorbis -ac 2 -b:a 160k OUTPUT.ogv
    
    FFmpeg 制作Mp3音频
        ffmpeg -i test.mp3 -c:a libmp3lame -ac 2 -b:a 160k OUTPUT.mp3
        
    FFmpeg 制作Ogg音频
        ffmpeg -i test.mp3 -c:a libvorbis -ac 2 -b:a 160k OUTPUT.ogg
    
    FFmpeg 制作ACC音频	
        ffmpeg -i test.mp3 -c:a aac -ac 2 -b:a 160k OUTPUT.aac
</code></pre>
<p>​	<br>​	<br>​	</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5_canvas绘制矩形</title>
    <url>/2022/08/20/02_canvas(%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2)/</url>
    <content><![CDATA[<pre><code>HTML中的元素canvas只支持一种原生的图形绘制：矩形。所有其他的图形的绘制都至少需要生成一条路径

1.绘制矩形
    canvas提供了三种方法绘制矩形：
        ----&gt;绘制一个填充的矩形（填充色默认为黑色）
            fillRect(x, y, width, height)
        ----&gt;绘制一个矩形的边框（默认边框为:一像素实心黑色）
            strokeRect(x, y, width, height)
        ----&gt;清除指定矩形区域，让清除部分完全透明。	
            clearRect(x, y, width, height)
            
    x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。
    width和height设置矩形的尺寸。（存在边框的话，边框会在width上占据一个边框的宽度，height同理）

2.strokeRect时，边框像素渲染问题
    按理渲染出的边框应该是1px的，
    canvas在渲染矩形边框时，边框宽度是平均分在偏移位置的两侧。
        context.strokeRect(10,10,50,50)
            :边框会渲染在10.5 和 9.5之间,浏览器是不会让一个像素只用自己的一半的
              相当于边框会渲染在9到11之间
        context.strokeRect(10.5,10.5,50,50)
            :边框会渲染在10到11之间

3.添加样式和颜色
    fillStyle   :设置图形的填充颜色。
    strokeStyle :设置图形轮廓的颜色。
        默认情况下，线条和填充颜色都是黑色（CSS 颜色值 #000000）
    lineWidth : 这个属性设置当前绘线的粗细。属性值必须为正数。
        描述线段宽度的数字。 0、 负数、 Infinity 和 NaN 会被忽略。
        默认值是1.0。
        
4.lineWidth &amp; 覆盖渲染

5.lineJoin
    设定线条与线条间接合处的样式（默认是 miter）
    round : 圆角
    bevel : 斜角
    miter : 直角
</code></pre>
<p>​		<br>​		</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5概述 根元素</title>
    <url>/2022/08/19/02_%E6%A0%B9%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<pre><code>H4中的根元素:
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    
    首先这个标记没有任何问题，你喜欢的话,那就背下来继续用。它是有效的。
    但这个标记中的很多字节在Html5中我们都可以省略了
    
    xmlns:这是XHTML1.0的东西，
        它的意思是在这个页面上的元素都位于http://www.w3.org/1999/xhtml这个命名空间内
        但是HTML5中的每个元素都具有这个命名空间，不需要在页面上再显示指出
</code></pre>
<p>​			<br>    H5中的根元素<br>        </p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5表单</title>
    <url>/2022/08/18/02_%E7%96%AF%E7%8B%82%E7%9A%84%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<pre><code>Html5 Forms概述,在Html5中:
    1.表单仍然使用&lt;form&gt;元素作为容器,我们可以在其中设置基本的提交特性
        form的action指向一个服务器地址（接口）
    2.当用户或开发人员提交页面时,表单仍然用于向服务端发送表单中控件的值
        注意表单项的name属性必须有值，服务器才能获取表单
    3.所有之前的表单控件都保持不变
    4.仍然可以使用脚本操作表单控件
    5.Htnl5之前的表单
        标签为input
            type:text:文本框
            type:password:密码框
            type:radio:单选按钮
                注意以name分组，确保单选关系，也为了后台能成功获取
                必须有value属性，为了后台获取后的识别（不写统一为on）
                checked属性,选中控制
            type:checkbox:复选框
                注意以name分组，确保为一组，也为了后台能成功获取
                必须有value属性，为了后台获取后的识别（不写统一为on）
                checked属性,选中控制
            type:submit:提交按钮
            type:reset:重置按钮
            type:button:普通按钮
        
        标签为select:下拉框
            name属性在select标签上
            multiple:可选多项
            子项可以通过optgroup来进行分组
                label属性用来定义组名
                子项为option标签
                    selected属性,选中控制
                    必须有value属性,为了后台获取后的识别
        
        标签为textarea:文本域
        
        标签为button:按钮
            type:submit:提交按钮
            type:reset:重置按钮
            type:button:普通按钮
            
        标签为lable:控制文本与表单的关系
            for属性指向一个input的id
            
        标签fieldset 标签legend:来为表单分组	
                
    6.attr &amp; prop
    7.Html5 新增
</code></pre>
<h3 id="新增表单控件"><a href="#新增表单控件" class="headerlink" title="新增表单控件"></a>新增表单控件</h3><pre><code>    1.type:email :email地址类型
        当格式不符合email格式时，提交是不会成功的，会出现提示；只有当格式相符时，提交才会通过
        在移动端获焦的时候会切换到英文键盘
        
    2.type:tel :电话类型
        在移动端获焦的时候会切换到数字键盘
    
    3.type:url :url类型
        当格式不符合url格式时，提交是不会成功的，会出现提示；只有当格式相符时，提交才会通过
        
    4.type:search :搜索类型
        有清空文本的按钮
        
    5.type:range  :  特定范围内的数值选择器
        属性:min、max、step
    
    6.
      type:number          :  只能包含数字的输入框
      type:color  	       		:  颜色选择器
      type:datetime        	 :  显示完整日期(移动端浏览器支持)
      type:datetime-local  :  显示完整日期，不含时区
      type:time            :  显示时间，不含时区
      type:date            :  显示日期
      type:week            :  显示周
      type:month           :  显示月
</code></pre>
<p>​			</p>
<h3 id="新增表单属性"><a href="#新增表单属性" class="headerlink" title="新增表单属性"></a>新增表单属性</h3><pre><code>    placeholder  :  输入框提示信息
        适用于form,以及type为text,search,url,tel,email,password类型的input
        
    autofocus  :  指定表单获取输入焦点
    
    required  :  此项必填，不能为空
    
    pattern : 正则验证  pattern="\d{1,5}
    
    formaction 在submit里定义提交地址
    
    list和datalist  :  为输入框构造一个选择列表
                        list值为datalist标签的id
</code></pre>
<p>​		<br>​		</p>
<h3 id="表单验证反馈"><a href="#表单验证反馈" class="headerlink" title="表单验证反馈"></a>表单验证反馈</h3><pre><code>validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都通过返回true，一种验证失败返回false
node.addEventListener("invalid",fn1,false);

valueMissing  	 :  输入值为空时返回true
typeMismatch 	 :  控件值与预期类型不匹配返回true
patternMismatch  :  输入值不满足pattern正则返回true

tooLong  		 :  超过maxLength最大限制返回true
rangeUnderflow   :  验证的range最小值返回true
rangeOverflow    :  验证的range最大值返回true
stepMismatch     :  验证range 的当前值 是否符合min、max及step的规则返回true

customError 不符合自定义验证返回true
    setCustomValidity
</code></pre>
<h3 id="关闭验证"><a href="#关闭验证" class="headerlink" title="关闭验证"></a>关闭验证</h3><pre><code>formnovalidate属性
</code></pre>
<p>​		</p>
<p>​		</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5_canvas绘制路径</title>
    <url>/2022/08/20/03_canvas(%E7%BB%98%E5%88%B6%E8%B7%AF%E5%BE%84)/</url>
    <content><![CDATA[<pre><code>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。
</code></pre>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><pre><code>1.首先，你需要创建路径起始点。
2.然后你使用画图命令去画出路径
3.之后你把路径封闭。
4.一旦路径生成，你就能通过描边或填充路径区域来渲染图形。
</code></pre>
<h3 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h3><pre><code>beginPath()
    新建一条路径，生成之后，图形绘制命令被指向到路径上准备生成路径。
    
    生成路径的第一步叫做beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，
    所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，列表清空重置，
    然后我们就可以重新绘制新的图形。

moveTo(x, y)
    将笔触移动到指定的坐标x以及y上
    当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点
    
lineTo(x, y)
    将笔触移动到指定的坐标x以及y上
    绘制一条从当前位置到指定x以及y位置的直线。

closePath()
    闭合路径之后图形绘制命令又重新指向到上下文中。
        闭合路径closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。
    如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做
        当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。
    但是调用stroke()时不会自动闭合
    
stroke()
    通过线条来绘制图形轮廓。
    不会自动调用closePath()
    
fill()
    通过填充路径的内容区域生成实心的图形。
    自动调用closePath()
</code></pre>
<p>###绘制矩形<br>    rect(x, y, width, height)<br>        绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。<br>        当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。<br>        也就是说，当前笔触自动重置会默认坐标</p>
<h3 id="lineCap"><a href="#lineCap" class="headerlink" title="lineCap"></a>lineCap</h3><pre><code>lineCap 是 Canvas 2D API 指定如何绘制每一条线段末端的属性。
有3个可能的值，分别是：
    butt  :线段末端以方形结束。 
    round :线段末端以圆形结束
    square:线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域
默认值是 butt。
</code></pre>
<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><pre><code>save() 是 Canvas 2D API 通过将当前状态放入栈中，保存 canvas 全部状态的方法

保存到栈中的绘制状态有下面部分组成：
    当前的变换矩阵。
    当前的剪切区域。
    当前的虚线列表.
    以下属性当前的值： strokeStyle, 
                 fillStyle,  
                 lineWidth, 
                 lineCap, 
                 lineJoin...
</code></pre>
<h3 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h3><pre><code>restore() 是 Canvas 2D API 通过在绘图状态栈中弹出顶端的状态，将 canvas 恢复到最近的保存状态的方法。 
如果没有保存状态，此方法不做任何改变。	
</code></pre>
<p>​		<br>​		</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5音频视频2</title>
    <url>/2022/08/20/02_H5%E4%B8%AD%E5%AF%B9%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="html5标签"><a href="#html5标签" class="headerlink" title="html5标签"></a>html5标签</h3><pre><code>&lt;video&gt;:Html5提供的播放视频的标签
    src:资源地址
    controls:该属性定义是显示还是隐藏用户控制界面
    
&lt;audio&gt;:Html5提供的播放音频的标签
    src:资源地址
    controls:该属性定义是显示还是隐藏用户控制界面
    
&lt;source&gt;
    视频：
    type='video/webm; codecs="vp8, vorbis"'
    type='video/ogg; codecs="theora, vorbis"'
    type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'
    
    音频：
    type='audio/ogg; codecs="vorbis"'
    type='audio/aac; codecs="aac"'
    type='audio/mpeg'
</code></pre>
<h3 id="video标签的属性"><a href="#video标签的属性" class="headerlink" title="video标签的属性"></a>video标签的属性</h3><pre><code>width  :视频显示区域的宽度，单位是CSS像素
height :视频展示区域的高度，单位是CSS像素
poster :一个海报帧的URL，用于在用户播放或者跳帧之前展示

src		  :	   要嵌到页面的视频的URL
controls  :  显示或隐藏用户控制界面
autoplay  :  媒体是否自动播放
loop  	  :  媒体是否循环播放
muted  	  :  是否静音
preload   :  该属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么
                none: 提示作者认为用户不需要查看该视频，服务器也想要最小化访问流量；
                          换句话说就是提示浏览器该视频不需要缓存。
                metadata: 提示尽管作者认为用户不需要查看该视频，
                             不过抓取元数据（比如：长度）还是很合理的。
                auto: 用户需要这个视频优先加载；换句话说就是提示：如果需要的话，
                         可以下载整个视频，即使用户并不一定会用它。
                空字符串：也就代指 auto 值。
</code></pre>
<h3 id="audio标签的属性"><a href="#audio标签的属性" class="headerlink" title="audio标签的属性"></a>audio标签的属性</h3><pre><code>src		  
controls  
autoplay  
loop  	  
muted  	  
preload   
</code></pre>
<p>​	</p>
<h3 id="音视频js相关属性"><a href="#音视频js相关属性" class="headerlink" title="音视频js相关属性"></a>音视频js相关属性</h3><pre><code>duration    :  媒体总时间(只读)
currentTime :  开始播放到现在所用的时间(可读写)
muted       :  是否静音(可读写,相比于volume优先级要高)
volume      :  0.0-1.0的音量相对值(可读写)
paused      :  媒体是否暂停(只读)
ended       :  媒体是否播放完毕(只读)
error       :  媒体发生错误的时候，返回错误代码 (只读)
currentSrc  :  以字符串的形式返回媒体地址(只读)
</code></pre>
<p>​	<br>    视频多的部分:<br>        poster  :   视频播放前的预览图片(读写)<br>        width、height  :   设置视频的尺寸(读写)<br>        videoWidth、 videoHeight  :   视频的实际尺寸(只读)</p>
<h3 id="音视频js相关函数"><a href="#音视频js相关函数" class="headerlink" title="音视频js相关函数"></a>音视频js相关函数</h3><pre><code>play()  :  媒体播放
pause()  :  媒体暂停
load()  :  重新加载媒体
</code></pre>
<p>​	</p>
<h3 id="js相关事件"><a href="#js相关事件" class="headerlink" title="js相关事件"></a>js相关事件</h3><pre><code>视频:
    abort	 在播放被终止时触发,例如, 当播放中的视频重新开始播放时会触发这个事件。
    canplay	在媒体数据已经有足够的数据（至少播放数帧）可供播放时触发。这个事件对应CAN_PLAY的readyState。
    canplaythrough	在媒体的readyState变为CAN_PLAY_THROUGH时触发，表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。注意：手动设置currentTime会使得firefox触发一次canplaythrough事件，其他浏览器或许不会如此。
    durationchange	元信息已载入或已改变，表明媒体的长度发生了改变。例如，在媒体已被加载足够的长度从而得知总长度时会触发这个事件。
    emptied	媒体被清空（初始化）时触发。
    ended	播放结束时触发。
    error	在发生错误时触发。元素的error属性会包含更多信息。参阅Error handling获得详细信息。
    loadeddata	媒体的第一帧已经加载完毕。
    loadedmetadata	媒体的元数据已经加载完毕，现在所有的属性包含了它们应有的有效信息。
    loadstart	在媒体开始加载时触发。
    mozaudioavailable	当音频数据缓存并交给音频层处理时
    pause	播放暂停时触发。
    play	在媒体回放被暂停后再次开始时触发。即，在一次暂停事件后恢复媒体回放。
    playing	在媒体开始播放时触发（不论是初次播放、在暂停后恢复、或是在结束后重新开始）。
    progress	告知媒体相关部分的下载进度时周期性地触发。有关媒体当前已下载总计的信息可以在元素的buffered属性中获取到。
    ratechange	在回放速率变化时触发。
    seeked	在跳跃操作完成时触发。
    seeking	在跳跃操作开始时触发。
    stalled	在尝试获取媒体数据，但数据不可用时触发。
    suspend	在媒体资源加载终止时触发，这可能是因为下载已完成或因为其他原因暂停。
    timeupdate	元素的currentTime属性表示的时间已经改变。
    volumechange	在音频音量改变时触发（既可以是volume属性改变，也可以是muted属性改变）.。
    waiting	在一个待执行的操作（如回放）因等待另一个操作（如跳跃或下载）被延迟时触发

音频:
    abort	 在播放被终止时触发,例如, 当播放中的视频重新开始播放时会触发这个事件。
    canplay	在媒体数据已经有足够的数据（至少播放数帧）可供播放时触发。这个事件对应CAN_PLAY的readyState。
    canplaythrough	在媒体的readyState变为CAN_PLAY_THROUGH时触发，表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。注意：手动设置currentTime会使得firefox触发一次canplaythrough事件，其他浏览器或许不会如此。
    durationchange	元信息已载入或已改变，表明媒体的长度发生了改变。例如，在媒体已被加载足够的长度从而得知总长度时会触发这个事件。
    emptied	媒体被清空（初始化）时触发。
    ended	播放结束时触发。
    error	在发生错误时触发。元素的error属性会包含更多信息。参阅Error handling获得详细信息。
    loadeddata	媒体的第一帧已经加载完毕。
    loadedmetadata	媒体的元数据已经加载完毕，现在所有的属性包含了它们应有的有效信息。
    loadstart	在媒体开始加载时触发。
    mozaudioavailable	当音频数据缓存并交给音频层处理时
    pause	播放暂停时触发。
    play	在媒体回放被暂停后再次开始时触发。即，在一次暂停事件后恢复媒体回放。
    playing	在媒体开始播放时触发（不论是初次播放、在暂停后恢复、或是在结束后重新开始）。
    progress	告知媒体相关部分的下载进度时周期性地触发。有关媒体当前已下载总计的信息可以在元素的buffered属性中获取到。
    ratechange	在回放速率变化时触发。
    seeked	在跳跃操作完成时触发。
    seeking	在跳跃操作开始时触发。
    stalled	在尝试获取媒体数据，但数据不可用时触发。
    suspend	在媒体资源加载终止时触发，这可能是因为下载已完成或因为其他原因暂停。
    timeupdate	元素的currentTime属性表示的时间已经改变。
    volumechange	在音频音量改变时触发（既可以是volume属性改变，也可以是muted属性改变）.。
    waiting	在一个待执行的操作（如回放）因等待另一个操作（如跳跃或下载）被延迟时触发
</code></pre>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5概述 head元素</title>
    <url>/2022/08/20/03_head%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<pre><code>MIME类型:
    每当浏览器请求一个页面时，web服务器会在发送实际页面内容之前，先发送一些头信息。
    浏览器需要这些信息来决定如何解析随后的页面内容。最重要的是Content-Type
    
    比如: Content-Type:text/html
    
    text/html:即这个页面的"内容类型",或者称为MIME类型。这个头信息将唯一确定某个资源的本质是什么
    也决定了它应该如何被呈现。
    
    图片也有自己的MIME类型		
        jpg:image/jpeg   
        png:image/png
        
    js也有自己的MIME类型，css也有自己的MIME类型，
        任何资源都有自己的MIME类型，整个web都依靠MIME类型来运作
</code></pre>
<p>​			<br>​			<br>    <meta charset="UTF-8">:<br>        告诉浏览器你应该使用哪种编码来解析网页</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5_canvas绘制圆形</title>
    <url>/2022/08/20/04_canvas(%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2)/</url>
    <content><![CDATA[<h3 id="角度与弧度的js表达式-radians-x3D-Math-PI-x2F-180-degrees。"><a href="#角度与弧度的js表达式-radians-x3D-Math-PI-x2F-180-degrees。" class="headerlink" title="角度与弧度的js表达式:radians=(Math.PI/180)*degrees。"></a>角度与弧度的js表达式:radians=(Math.PI/180)*degrees。</h3><h3 id="canvas绘制圆形"><a href="#canvas绘制圆形" class="headerlink" title="canvas绘制圆形"></a>canvas绘制圆形</h3><pre><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)
        画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，
        按照anticlockwise给定的方向（默认为顺时针）来生成。
        ture：逆时针
        false:顺时针
    
    x,y为绘制圆弧所在圆上的圆心坐标
    radius为半径
    startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以x轴为基准
    参数anticlockwise 为一个布尔值。为true时，是逆时针方向，否则顺时针方向。
</code></pre>
<h3 id="arcTo"><a href="#arcTo" class="headerlink" title="arcTo"></a>arcTo</h3><pre><code>arcTo(x1, y1, x2, y2, radius)
根据给定的控制点和半径画一段圆弧
肯定会从(x1 y1)  但不一定经过(x2 y2);(x2 y2)只是控制一个方向
</code></pre>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5新增加标签</title>
    <url>/2022/08/20/03_%E5%85%B6%E4%BB%96%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<pre><code>meter:用来显示已知范围的标量值或者分数值。
    value:当前的数值。
    min:值域的最小边界值。如果设置了，它必须比最大值要小。如果没设置，默认为0
    max:值域的上限边界值。如果设置了，它必须比最小值要大。如果没设置，默认为1
    low:定义了低值区间的上限值,如果设置了，它必须比最小值属性大，并且不能超过high值和最大值。未设置或者比最小值还要小时，其值即为最小值。
    high:定义了高值区间的下限值。如果设置了，它必须小于最大值，同时必须大于low值和最小值。如果没有设置，或者比最大值还大，其值即为最大值。
    optimum:这个属性用来指示最优/最佳取值。

progress:用来显示一项任务的完成进度
    max:该属性描述了这个progress元素所表示的任务一共需要完成多少工作.
    value：该属性用来指定该进度条已完成的工作量.
            如果没有value属性,则该进度条的进度为"不确定",
            也就是说,进度条不会显示任何进度,你无法估计当前的工作会在何时完成
</code></pre>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><pre><code>datalist:datalist会包含一组option元素，这些元素表示其表单控件的可选值
            它的id必须要和input中的list一致

details: 一个ui小部件，用户可以从其中检索附加信息。
        open属性来控制附加信息的显示与隐藏
summary:用作 一个&lt;details&gt;元素的一个内容摘要（标题）
</code></pre>
<h3 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h3><pre><code>ruby
rt: 展示文字注音或字符注释。
</code></pre>
<h3 id="标记标签"><a href="#标记标签" class="headerlink" title="标记标签"></a>标记标签</h3><pre><code>marK:着重
</code></pre>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5音频视频功能逻辑</title>
    <url>/2022/08/20/04_%E5%8A%9F%E8%83%BD%E7%82%B9%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<pre><code>播放按钮点击时:
    切换播放按钮的样式
    控制视频的播放暂停
        播放:控制进度条的前进(通过开启定时器来实现)
        暂停:要关闭定时器不让进度条前进
        
停止按钮点击时
    切换播放按钮的样式
    控制视频暂停
        暂停:要关闭定时器不让进度条前进
    进度条重置为0
    视频时间调整为0
    
拖拽时根据拖拽距离控制视频时间

点击进度条时,根据点击位置控制视频时间
    点击进度条时,默认就应该是播放操作
    切换播放按钮的样式
    控制视频的播放
        :控制进度条的前进:通过开启定时器来实现
</code></pre>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5资源参数</title>
    <url>/2022/08/20/03_%E8%B5%84%E6%BA%90&amp;%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="http-s8-qhimg-com-share-audio-piano1-a4-mp3"><a href="#http-s8-qhimg-com-share-audio-piano1-a4-mp3" class="headerlink" title="http://s8.qhimg.com/share/audio/piano1/a4.mp3"></a><a href="http://s8.qhimg.com/share/audio/piano1/a4.mp3">http://s8.qhimg.com/share/audio/piano1/a4.mp3</a></h3><h3 id="http-www-17sucai-com-preview-87827-2017-11-07-video1-video-mp4"><a href="#http-www-17sucai-com-preview-87827-2017-11-07-video1-video-mp4" class="headerlink" title="http://www.17sucai.com/preview/87827/2017-11-07/video1/video.mp4"></a><a href="http://www.17sucai.com/preview/87827/2017-11-07/video1/video.mp4">http://www.17sucai.com/preview/87827/2017-11-07/video1/video.mp4</a></h3><h3 id="http-www-17sucai-com-preview-501914-2017-08-04-E9-A1-B5-E9-9D-A2-media-mov-bbb-mp4"><a href="#http-www-17sucai-com-preview-501914-2017-08-04-E9-A1-B5-E9-9D-A2-media-mov-bbb-mp4" class="headerlink" title="http://www.17sucai.com/preview/501914/2017-08-04/%E9%A1%B5%E9%9D%A2/media/mov_bbb.mp4"></a><a href="http://www.17sucai.com/preview/501914/2017-08-04/%E9%A1%B5%E9%9D%A2/media/mov_bbb.mp4">http://www.17sucai.com/preview/501914/2017-08-04/%E9%A1%B5%E9%9D%A2/media/mov_bbb.mp4</a></h3><h3 id="自定义播放器主要参数"><a href="#自定义播放器主要参数" class="headerlink" title="自定义播放器主要参数"></a>自定义播放器主要参数</h3><pre><code>全局背景色：#383838
底部控制条：25px 高度
底部控制条背景色:#2A2A2A

主进度条的大小:宽度自适应,两边margin:55 230
    进度条的高度:3px 背景色:#737373
    进度条小方块尺寸:宽9 * 高7 ; 背景白色 ; 2px圆角
</code></pre>
<p>​	<br>    按钮排的大小:宽55 * 高25<br>        按钮大小:宽9 * 高11</p>
<p>​		<br>    右侧信息栏的大小:宽230 * 高25<br>        文字部分:宽120<br>            字体大小:12px<br>            颜色:white</p>
<pre><code>    声音:宽80
        切换控件:宽20 高25
            子项:	margin: 7px auto;
                    width: 12px;
                    height: 12px;
                    background: url(images/icon.png) no-repeat;
                    background-position:0 -34px;
                    
                    active:background-position: 0 -46px;
        进度条:宽60 高25

    全屏:宽30
          子项:display: inline-block;
             margin: 7px auto;
             width: 11px;
             height: 11px;
             background: url(images/icon.png) no-repeat;
             background-position: 0 -58px;
             
             active:background-position: 0 -70px;
</code></pre>
<h3 id="class操作函数"><a href="#class操作函数" class="headerlink" title="class操作函数"></a>class操作函数</h3><pre><code>function addClass(node,className){
    var reg=new RegExp("\\b"+className+"\\b");
    if(!reg.test(node.className)){
        node.className +=(" "+className); 
    }
}
function removeClass(node,className){
    if(node.className){
        var reg=new RegExp("\\b"+className+"\\b");
        var classes = node.className;
        node.className=classes.replace(reg,"");
        if(/^\s*$/g.test(node.className)){
            node.removeAttribute("class");
        }
    }else{
        node.removeAttribute("class");
    }
}
</code></pre>
<h3 id="全屏实现"><a href="#全屏实现" class="headerlink" title="全屏实现"></a>全屏实现</h3><pre><code>full.onclick=function() {
    if(isFullScreen) {
        isFullScreen = false
        if (document.exitFullscreen) {  
            document.exitFullscreen();  
        }  
        else if (document.mozCancelFullScreen) {  
            document.mozCancelFullScreen();  
        }  
        else if (document.webkitCancelFullScreen) {  
            document.webkitCancelFullScreen();  
        }
        else if (document.msExitFullscreen) {
              document.msExitFullscreen();
        }
    } else {
        isFullScreen = true
        var docElm = document.documentElement;
        //W3C  
        if (docElm.requestFullscreen) {  
            docElm.requestFullscreen();  
        }
        //FireFox  
        else if (docElm.mozRequestFullScreen) {  
            docElm.mozRequestFullScreen();  
        }
        //Chrome等  
        else if (docElm.webkitRequestFullScreen) {  
            docElm.webkitRequestFullScreen();  
        }
        //IE11
        else if (docElm.msRequestFullscreen) {
          docElm.msRequestFullscreen();
        }
    }
}
</code></pre>
<h3 id="window10-下环境变量的入口"><a href="#window10-下环境变量的入口" class="headerlink" title="window10 下环境变量的入口"></a>window10 下环境变量的入口</h3><pre><code>控制面板--&gt;选择大图标--&gt;系统--&gt;高级系统设置--&gt;高级--&gt;环境变量
</code></pre>
<h3 id="video写法"><a href="#video写法" class="headerlink" title="video写法"></a>video写法</h3><pre><code>&lt;video width="800" height=""&gt;
    &lt;source src="myvideo.mp4" type="video/mp4"&gt;&lt;/source&gt;
    &lt;source src="myvideo.ogv" type="video/ogg"&gt;&lt;/source&gt;
    &lt;source src="myvideo.webm" type="video/webm"&gt;&lt;/source&gt;
    &lt;object width="" height="" type="application/x-shockwave-flash" data="myvideo.swf"&gt;
        &lt;param name="movie" value="myvideo.swf" /&gt;
        &lt;param name="flashvars" value="autostart=true&amp;amp;file=myvideo.swf" /&gt;
    &lt;/object&gt;
    当前浏览器不支持 video直接播放，点击这里下载视频： &lt;a href="myvideo.webm"&gt;下载视频&lt;/a&gt;
&lt;/video&gt;
</code></pre>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5概述 语义化标签</title>
    <url>/2022/08/20/04_%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<pre><code>在HTML 5出来之前，我们用div来表示页面头部，章节，页脚等。但是这些div都没有实际意义。
各大浏览器厂商分析了上百万的页面，从中发现了DIV名称的通用id名称大量重复。例如，很多开发人员喜欢使用
div id="footer"来标记页脚内容，所以Html5元素引入了语义化标签（一组新的片段类元素）

https://dev.opera.com/blog/presentation-html5-and-accessibility-sitting-in-a-tree-4/idlist-url.htm
https://dev.opera.com/blog/presentation-html5-and-accessibility-sitting-in-a-tree-4/classlist-url.htm

&lt;hgroup&gt;&lt;/hgroup&gt;
&lt;header&gt;&lt;/header&gt;
&lt;nav&gt;&lt;/nav&gt;
&lt;section&gt;&lt;/section&gt;
&lt;footer&gt;&lt;/footer&gt;
&lt;article&gt;&lt;/article&gt;
&lt;aside&gt;&lt;/aside&gt;
</code></pre>
<p>​	<br>    语义化的好处<br>        HTML5可以让很多更语义化结构化的代码标签代替大量的无意义的div标签<br>        这种语义化的特性提升了网页的质量和语义<br>        对搜索引擎更加的友好<br>    他们这些标签功能就是代替</p><div>功能中的一部分，他们没有任何的默认样式，除了会让文本另起一行外；<br>    <a href="https://gsnedders.html5.org/outliner/">https://gsnedders.html5.org/outliner/</a><p></p>
<p>​	<br>    hgroup元素代表 网页 或 section 的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题的组合</p>
<pre><code>    &lt;hgroup&gt;
        &lt;h1&gt;HTML 5&lt;/h1&gt;
        &lt;h2&gt;这是一篇介绍HTML 5语义化标签和更简洁的结构&lt;/h2&gt;
    &lt;/hgroup&gt;

    hgroup使用注意：
        如果只需要一个h1-h6标签就不用hgroup
        如果有连续多个h1-h6标签就用hgroup
        如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签
</code></pre>
<p>​	<br>    header 元素代表 网页 或 section 的页眉。<br>        通常包含h1-h6元素或hgroup</p>
<pre><code>    &lt;header&gt;
        &lt;hgroup&gt;
            &lt;h1&gt;网站标题&lt;/h1&gt;
            &lt;h2&gt;网站副标题&lt;/h2&gt;
        &lt;/hgroup&gt;
    &lt;/header&gt;
    
    header使用注意：
        可以是“网页”或任意“section”的头部部分
        没有个数限制。
        如果hgroup或h1-h6自己就能工作的很好，那就不要用header。



nav元素代表页面的导航链接区域。用于定义页面的主要导航部分。

    &lt;nav&gt;
        &lt;ul&gt;
            &lt;li&gt;HTML 5&lt;/li&gt;
            &lt;li&gt;CSS3&lt;/li&gt;
            &lt;li&gt;JavaScript&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/nav&gt;
    
    nav使用注意：
        用在整个页面主要导航部分上，不合适就不要用nav元素；
</code></pre>
<p>​	<br>​	<br>    section元素代表文档中的 节 或 段，段可以是指一篇文章里按照主题的分段；节可以是指一个页面里的分组。</p>
<pre><code>    &lt;section&gt;
        &lt;h1&gt;section是啥？&lt;/h1&gt;
        &lt;article&gt;
            &lt;h2&gt;关于section&lt;/h1&gt;
            &lt;p&gt;section的介绍&lt;/p&gt;
            &lt;section&gt;
                &lt;h3&gt;关于其他&lt;/h3&gt;
                &lt;p&gt;关于其他section的介绍&lt;/p&gt;
            &lt;/section&gt;
        &lt;/article&gt;
    &lt;/section&gt;
    
    section使用注意：
        section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。
        article、nav、aside可以理解为特殊的section，
        所以如果可以用article、nav、aside就不要用section，没实际意义的就用div		
</code></pre>
<p>​		<br>​		<br>    article元素最容易跟section和div容易混淆，其实article代表一个在文档，页面或者网站中自成一体的内容</p>
<pre><code>    &lt;article&gt;
        &lt;h1&gt;一篇文章&lt;/h1&gt;
        &lt;p&gt;文章内容..&lt;/p&gt;
        &lt;footer&gt;
            &lt;p&gt;&lt;small&gt;版权：html5jscss网所属，作者：damu&lt;/small&gt;&lt;/p&gt;
        &lt;/footer&gt;
    &lt;/article&gt;
    
    article使用注意：
        独立文章：用article
        单独的模块：用section
        没有语义的：用div
</code></pre>
<p>​		<br>​		<br>    aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等</p>
<pre><code>    在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。
    
    &lt;article&gt;
        &lt;p&gt;内容&lt;/p&gt;
        &lt;aside&gt;
            &lt;h1&gt;作者简介&lt;/h1&gt;
            &lt;p&gt;小北，前端一枚&lt;/p&gt;
        &lt;/aside&gt;
    &lt;/article&gt;
    
    aside使用总结：
        aside在article内表示主要内容的附属信息，
        在article之外则可做侧边栏
        如果是广告，其他日志链接或者其他分类导航也可以用
</code></pre>
<p>​	<br>​	<br>​	<br>    footer元素代表 网页 或 section 的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。</p>
<pre><code>    &lt;footer&gt;
        COPYRIGHT@damu
    &lt;/footer&gt;
    
    footer使用注意：
        可以是 网页 或任意 section 的底部部分；
        没有个数限制，除了包裹的内容不一样，其他跟header类似。
</code></pre>
</div>]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5_canvas变换</title>
    <url>/2022/08/20/06_canvas(%E5%8F%98%E6%8D%A2)/</url>
    <content><![CDATA[<pre><code>translate(x, y)
    我们先介绍 translate 方法，它用来移动 canvas的原点到一个不同的位置。
    translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，
    
    在canvas中translate是累加的

rotate(angle)
    这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。
    旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法
    
    在canvas中rotate是累加的
    
scale(x, y)
    scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。
    值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。
    缩放一般我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。
    
    在canvas中scale是累称的
</code></pre>
<h3 id="表盘"><a href="#表盘" class="headerlink" title="表盘"></a>表盘</h3><pre><code>1.初始化
    将圆心调整到画布的中间
    由于canvas中画圆与旋转所参照的坐标系于正常坐标系有出入
        将整个画布逆时针旋转90度
    初始化一些样式数据
        ctx.lineWidth = 8;
      	ctx.strokeStyle = "black";
      	ctx.lineCap = "round";

2.外层空心圆盘
    圆盘颜色:#325FA2
    圆盘宽度:14
    圆盘半径:140
    
3.时针刻度
    长度为20
    宽度为8
    外层空心圆盘与时针刻度之间的距离也为20
    
4.分针刻度
    宽度为4
    长度为3
    
5.时针
    宽度为14
    圆心外溢出80 收20
    
6.分针
    宽度为10
    圆心外溢出112 收28
    
7.秒针
    颜色:D40000
    宽度为6
    圆心外溢出83 收30
    
    ----&gt;中心实心圆盘
        半径为10
    ----&gt;秒针头
        96码开外半径为10的空心圆
        宽度为6
</code></pre>
<p>​		<br>​	</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5_canvas贝塞尔</title>
    <url>/2022/08/20/05_canvas(%E8%B4%9D%E5%A1%9E%E5%B0%94)/</url>
    <content><![CDATA[<h3 id="二次贝塞尔"><a href="#二次贝塞尔" class="headerlink" title="二次贝塞尔"></a>二次贝塞尔</h3><pre><code>quadraticCurveTo(cp1x, cp1y, x, y)
    绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。
    起始点为moveto时指定的点
</code></pre>
<h3 id="三次贝塞尔"><a href="#三次贝塞尔" class="headerlink" title="三次贝塞尔"></a>三次贝塞尔</h3><pre><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
    绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。
    起始点为moveto时指定的点
</code></pre>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5_ canvas文本</title>
    <url>/2022/08/20/08_canvas(%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC)/</url>
    <content><![CDATA[<h3 id="在canvas中绘制文本"><a href="#在canvas中绘制文本" class="headerlink" title="在canvas中绘制文本"></a>在canvas中绘制文本</h3><pre><code>canvas 提供了两种方法来渲染文本:
    fillText(text, x, y)
        在指定的(x,y)位置填充指定的文本
    strokeText(text, x, y)
        在指定的(x,y)位置绘制文本边框
</code></pre>
<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><pre><code>font = value
    当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 
    默认的字体是 10px sans-serif。
    font属性在指定时，必须要有大小和字体 缺一不可
    
textAlign = value
    文本对齐选项. 可选的值包括： left, right  center. 
    left
        文本左对齐。
    right
        文本右对齐。
    center
        文本居中对齐。
        这里的textAlign="center"比较特殊。textAlign的值为center时候
        文本的居中是基于你在fillText的时候所给的x的值，
        也就是说文本一半在x的左边，一半在x的右边
</code></pre>
<p>​	<br>    textBaseline = value<br>        描述绘制文本时，当前文本基线的属性。<br>        top<br>            文本基线在文本块的顶部。<br>        middle<br>            文本基线在文本块的中间。<br>        bottom<br>            文本基线在文本块的底部。</p>
<h3 id="measureText"><a href="#measureText" class="headerlink" title="measureText"></a>measureText</h3><pre><code>measureText() 方法返回一个 TextMetrics 对象，包含关于文本尺寸的信息（例如文本的宽度）
</code></pre>
<h3 id="canvas中文本水平垂直居中"><a href="#canvas中文本水平垂直居中" class="headerlink" title="canvas中文本水平垂直居中"></a>canvas中文本水平垂直居中</h3><h3 id="阴影-文本阴影-amp-盒模型阴影"><a href="#阴影-文本阴影-amp-盒模型阴影" class="headerlink" title="阴影(文本阴影&amp;盒模型阴影)"></a>阴影(文本阴影&amp;盒模型阴影)</h3><pre><code>shadowOffsetX = float
    shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，
    它们默认都为 0。
shadowOffsetY = float
    shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，
    它们默认都为 0。
shadowBlur = float
    shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。
shadowColor = color(必需项)
    shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。
</code></pre>
<p>​	<br>​		</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5 canvas像素</title>
    <url>/2022/08/20/09_canvas(%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C)/</url>
    <content><![CDATA[<h3 id="在canvas中的像素操作"><a href="#在canvas中的像素操作" class="headerlink" title="在canvas中的像素操作"></a>在canvas中的像素操作</h3><pre><code>    到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，
你可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中
</code></pre>
<h3 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h3><pre><code>getImageData():获得一个包含画布场景像素数据的ImageData对像,它代表了画布区域的对象数据

ctx.getImageData(sx, sy, sw, sh)
    sx:将要被提取的图像数据矩形区域的左上角 x 坐标。
    sy:将要被提取的图像数据矩形区域的左上角 y 坐标。
    sw:将要被提取的图像数据矩形区域的宽度。
    sh:将要被提取的图像数据矩形区域的高度。
</code></pre>
<h3 id="ImageData对象"><a href="#ImageData对象" class="headerlink" title="ImageData对象"></a>ImageData对象</h3><pre><code>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：
    width:图片宽度，单位是像素
    height:图片高度，单位是像素
    data:Uint8ClampedArray类型的一维数组，
        包含着RGBA格式的整型数据，范围在0至255之间（包括255）
        R:0 --&gt; 255(黑色到白色)
        G:0 --&gt; 255(黑色到白色)
        B:0 --&gt; 255(黑色到白色)
        A:0 --&gt; 255(透明到不透明)
</code></pre>
<h3 id="在场景中写入像素数据"><a href="#在场景中写入像素数据" class="headerlink" title="在场景中写入像素数据"></a>在场景中写入像素数据</h3><pre><code>putImageData()方法去对场景进行像素数据的写入。
putImageData(myImageData, dx, dy)
    dx和dy参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标
</code></pre>
<h3 id="创建一个ImageData对象"><a href="#创建一个ImageData对象" class="headerlink" title="创建一个ImageData对象"></a>创建一个ImageData对象</h3><pre><code>ctx.createImageData(width, height);
    width : ImageData 新对象的宽度。
    height: ImageData 新对象的高度。
    
默认创建出来的是透明的
</code></pre>
<h3 id="操作单个像素（行与列）"><a href="#操作单个像素（行与列）" class="headerlink" title="操作单个像素（行与列）"></a>操作单个像素（行与列）</h3><h3 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h3><p>​	<br>​	<br>​	</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5_canvas合成</title>
    <url>/2022/08/20/10_canvas(%E5%90%88%E6%88%90)/</url>
    <content><![CDATA[<h3 id="全局透明度的设置"><a href="#全局透明度的设置" class="headerlink" title="全局透明度的设置"></a>全局透明度的设置</h3><pre><code>globalAlpha = value
    这个属性影响到 canvas 里所有图形的透明度，
    有效的值范围是 0.0 （完全透明）到 1.0（完全不透明）
    默认是 1.0
</code></pre>
<h3 id="覆盖合成"><a href="#覆盖合成" class="headerlink" title="覆盖合成"></a>覆盖合成</h3><pre><code>source:新的图像(源)
destination:已经绘制过的图形(目标)

globalCompositeOperation
    source-over(默认值):源在上面,新的图像层级比较高
    source-in  :只留下源与目标的重叠部分(源的那一部分)
    source-out :只留下源超过目标的部分
    source-atop:砍掉源溢出的部分
    
    destination-over:目标在上面,旧的图像层级比较高
    destination-in:只留下源与目标的重叠部分(目标的那一部分)
    destination-out:只留下目标超过源的部分
    destination-atop:砍掉目标溢出的部分
</code></pre>
<p>​		<br>​	<br>​	<br>​		<br>​		</p>
<p>​		<br>​	<br>​	<br>​	</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5其他</title>
    <url>/2022/08/20/11_canvas(others)/</url>
    <content><![CDATA[<h3 id="将画布导出为图像"><a href="#将画布导出为图像" class="headerlink" title="将画布导出为图像"></a>将画布导出为图像</h3><pre><code>toDataURL(注意是canvas元素接口上的方法)
</code></pre>
<h3 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h3><pre><code>ctx.isPointInPath(x, y)
    判断在当前路径中是否包含检测点
        x:检测点的X坐标
        y:检测点的Y坐标

注意，此方法只作用于最新画出的canvas图像
</code></pre>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>H5 canvas图片背景</title>
    <url>/2022/08/20/07_canvas(%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87&amp;%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF)/</url>
    <content><![CDATA[<h3 id="在canvas中插入图片-需要image对象"><a href="#在canvas中插入图片-需要image对象" class="headerlink" title="在canvas中插入图片(需要image对象)"></a>在canvas中插入图片(需要image对象)</h3><pre><code>1.canvas操作图片时，必须要等图片加载完才能操作
2.drawImage(image, x, y, width, height)
    其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。
    这个方法多了2个参数：width 和 height，这两个参数用来控制 当像canvas画入时应该缩放的大小
</code></pre>
<h3 id="在canvas中设置背景-需要image对象"><a href="#在canvas中设置背景-需要image对象" class="headerlink" title="在canvas中设置背景(需要image对象)"></a>在canvas中设置背景(需要image对象)</h3><pre><code>1.createPattern(image, repetition)
    image:图像源
    epetition:
        "repeat" 
        "repeat-x" 
        "repeat-y" 
        "no-repeat" 
        
一般情况下，我们都会将createPattern返回的对象作为fillstyle的值
</code></pre>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><pre><code>canvas渐变（线性渐变）
    createLinearGradient(x1, y1, x2, y2)
            表示渐变的起点 (x1,y1) 与终点 (x2,y2)
                
    gradient.addColorStop(position, color)
            gradient :createLinearGradient的返回值
            addColorStop 方法接受 2 个参数，
                position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。
                                例如，0.5 表示颜色会出现在正中间。
                color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）
</code></pre>
<p>​	<br>    canvas渐变（径向渐变）	<br>        createRadialGradient(x1, y1, r1, x2, y2, r2)<br>            前三个参数则定义另一个以(x1,y1) 为原点，半径为 r1 的圆，<br>            后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</p>
<p>​		</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础命令</title>
    <url>/2022/08/28/MySq%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mysql -h 主机地址 -u 用户名 －p 用户密码</span><br></pre></td></tr></tbody></table></figure>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">create database 数据名；</span><br></pre></td></tr></tbody></table></figure>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">drop database 数据库名</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></tbody></table></figure>

<h3 id="显示表"><a href="#显示表" class="headerlink" title="显示表"></a>显示表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">show tables</span><br></pre></td></tr></tbody></table></figure>

<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `ucvc_tbl`(</span><br><span class="line">   `ucvc_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `ucvc_title` VARCHAR(100) NOT NULL,</span><br><span class="line">   `ucvcb_author` VARCHAR(40) NOT NULL,</span><br><span class="line">   `ucvc_date` DATE,</span><br><span class="line">   PRIMARY KEY ( `ucvc_id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">DROP TABLE 表名 ;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">INSERT INTO 表名 ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></tbody></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM 表名</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M]</span><br><span class="line">// * 表示所有</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">UPDATE 表名 SET field1=new-value1, field2=new-value2</span><br><span class="line">[WHERE Clause]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE Clause]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//百分号 %字符来表示任意字符</span><br><span class="line">'%a'     //以a结尾的数据</span><br><span class="line">'a%'     //以a开头的数据</span><br><span class="line">'%a%'    //含有a的数据</span><br><span class="line">'_a_'    //三位且中间字母是a的</span><br><span class="line">'_a'     //两位且结尾字母是a的</span><br><span class="line">'a_'     //两位且开头字母是a的</span><br><span class="line"></span><br><span class="line">//查询以java开头的</span><br><span class="line">SELECT * FROM 表名 WHERE name LIKE 'java%';</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>**%**：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</p>
</li>
<li><p>**_**：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。</p>
</li>
<li><p>**[]**：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</p>
</li>
<li><p><strong>[^]</strong> ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</p>
</li>
<li><p>查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。</p>
</li>
</ol>
<p><strong>UNION 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）</p>
<p><strong>UNION ALL 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SELECT 列名称 FROM 表名称 UNION SELECT 列名称 FROM 表名称 ORDER BY 列名称；</span><br><span class="line">SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称；</span><br></pre></td></tr></tbody></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br><span class="line">//ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列</span><br></pre></td></tr></tbody></table></figure>

<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础常用命令</title>
    <url>/2022/08/28/git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ul>
<li><p>git init - 初始化仓库。</p>
</li>
<li><p>git add . - 添加文件到暂存区。</p>
</li>
<li><p>git commit - 将暂存区内容添加到仓库中。</p>
</li>
<li><p>git init -初始化仓库</p>
</li>
<li><p>git clone url -拷贝远程仓库</p>
</li>
<li><p>git status -查看仓库当前状态</p>
</li>
<li><p>git log -查看历史提交记录</p>
</li>
<li><p>git pull 主机名 分支名 -更新</p>
</li>
<li><p>git push 主机名 分支名 -上传代码</p>
</li>
<li><p>git reset -回退版本</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git reset HEAD^            # 回退所有内容到上一个版本  </span><br><span class="line">git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本  </span><br><span class="line">git  reset  052e           # 回退到指定版本</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery3</title>
    <url>/2022/08/09/jQuery2/</url>
    <content><![CDATA[<hr>
<ul>
<li><p>动画效果</p>
<ul>
<li>在一定的时间内, 不断改变元素样式</li>
<li>slideDown()/slideUp()/slideToggle()</li>
<li>fadeOut()/fadeIn()/fadeToggle()</li>
<li>show()/hide()/toggle()</li>
<li>animate({结束时的样式}, time, fun)</li>
<li>stop()</li>
</ul>
</li>
<li><p>插件机制</p>
<ul>
<li>扩展jQuery函数对象的方法<br>$.extend({<br>  xxx: fuction () {} // this是$<br>})<br>$.xxx()</li>
<li>扩展jQuery对象的方法<br>$.fn.extend({<br>  xxx: function(){}  // this是jQuery对象<br>})<br>$obj.xxx()</li>
</ul>
</li>
<li><p>jQuery文档的结构图</p>
</li>
</ul>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery1</title>
    <url>/2022/08/08/jQuery1/</url>
    <content><![CDATA[<ol>
<li>了解jQuery</li>
</ol>
<ul>
<li>是什么: What?<ul>
<li>一个JS函数库: write less, do more</li>
<li>封装简化DOM操作(CRUD) / Ajax</li>
</ul>
</li>
<li>为什么用它: why?<ul>
<li>强大选择器: 方便快速查找DOM元素</li>
<li>隐式遍历(迭代): 一次操作多个元素</li>
<li>读写合一: 读数据/写数据用的是一个函数</li>
<li>链式调用: 可以通过.不断调用jQuery对象的方法</li>
<li>事件处理</li>
<li>DOM操作(CUD)</li>
<li>样式操作</li>
<li>动画</li>
<li>浏览器兼容</li>
</ul>
</li>
<li>如何使用: How?<ul>
<li>引入jQuery库<ul>
<li>本地引入与CDN远程引入</li>
<li>测试版与生产版(压缩版)</li>
</ul>
</li>
<li>使用jQuery<ul>
<li>使用jQuery函数: $/jQuery</li>
<li>使用jQuery对象: $xxx(执行$()得到的)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>jQuery的2把利器</li>
</ol>
<ul>
<li>jQuery函数: $/jQuery<ul>
<li>jQuery向外暴露的就是jQuery函数, 可以直接使用</li>
<li>当成一般函数使用人: $(param)<ul>
<li>param是function: 相当于window.onload = function(文档加载完成的监听)</li>
<li>param是选择器字符串: 查找所有匹配的DOM元素, 返回包含所有DOM元素的jQuery对象</li>
<li>param是DOM元素: 将DOM元素对象包装为jQuery对象返回  $(this)</li>
<li>param是标签字符串: 创建标签DOM元素对象并包装为jQuery对象返回</li>
</ul>
</li>
<li>当成对象使用: $.xxx<ul>
<li>each(obj/arr, function(key, value){})</li>
<li>trim(str)</li>
</ul>
</li>
</ul>
</li>
<li>jQuery对象<ul>
<li>包含所有匹配的n个DOM元素的伪数组对象</li>
<li>执行$()返回的就是jQuery对象</li>
<li>基本行为:<ul>
<li>length/size(): 得到dom元素的个数</li>
<li></li>
<li>each(function(index, domEle){}): 遍历所有dom元素</li>
<li>index(): 得到当前dom元素在所有兄弟中的下标</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>选择器</li>
</ol>
<ul>
<li>是什么?<ul>
<li>有特定语法规则(css选择器)的字符串</li>
<li>用来查找某个/些DOM元素: $(selector)</li>
</ul>
</li>
<li>分类<ul>
<li>基本<ul>
<li>#id</li>
<li>tagName/*</li>
<li>.class</li>
<li>selector1,selector2,selector3: 并集</li>
<li>selector1selector2selector3: 交集</li>
</ul>
</li>
<li>层次<ul>
<li>找子孙后代, 兄弟元素</li>
<li>selector1&gt;selector2: 子元素</li>
<li>selector1 selector2: 后代元素</li>
</ul>
</li>
<li>过滤<ul>
<li>在原有匹配元素中筛选出其中一些</li>
<li>:first</li>
<li>:last</li>
<li>:eq(index)</li>
<li>:lt</li>
<li>:gt</li>
<li>:odd</li>
<li>:even</li>
<li>:not(selector)</li>
<li>:hidden</li>
<li>:visible</li>
<li>[attrName]</li>
<li>[attrName=value]</li>
</ul>
</li>
<li>表单<ul>
<li>:input</li>
<li>:text</li>
<li>:checkbox</li>
<li>:radio</li>
<li>:checked: 选中的</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>属性/文本</li>
</ol>
<ul>
<li>操作标签的属性, 标签体文本</li>
<li>attr(name) / attr(name, value): 读写非布尔值的标签属性</li>
<li>prop(name) / prop(name, value): 读写布尔值的标签属性</li>
<li>removeAttr(name)/removeProp(name): 删除属性</li>
<li>addClass(classValue): 添加class</li>
<li>removeClass(classValue): 移除指定class</li>
<li>val() / val(value): 读写标签的value</li>
<li>html() / html(htmlString): 读写标签体文本</li>
</ul>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery2</title>
    <url>/2022/08/10/jQuery3/</url>
    <content><![CDATA[<hr>
<ol>
<li>CSS模块</li>
</ol>
<ul>
<li>style样式<ul>
<li>css(styleName): 根据样式名得到对应的值</li>
<li>css(styleName, value): 设置一个样式</li>
<li>css({多个样式对}): 设置多个样式</li>
</ul>
</li>
<li>位置坐标<ul>
<li>offset(): 读/写当前元素坐标(原点是页面左上角)</li>
<li>position(): 读当前元素坐标(原点是父元素左上角)</li>
<li>scrollTop()/scrollLeft(): 读/写元素/页面的滚动条坐标</li>
</ul>
</li>
<li>尺寸<ul>
<li>width()/height(): width/height</li>
<li>innerWidth()/innerHeight(): width + padding</li>
<li>outerWidth()/outerHeight(): width + padding + border</li>
</ul>
</li>
</ul>
<ol start="2">
<li>筛选模块</li>
</ol>
<ul>
<li>过滤<ul>
<li>在jQuery对象内部的元素中找出部分匹配的元素, 并封装成新的jQuery对象返回</li>
<li>first()</li>
<li>last()</li>
<li>eq(index)</li>
<li>filter(selector): 对当前元素提要求</li>
<li>not(selector): 对当前元素提要求, 并取反</li>
<li>has(selector): 对子孙元素提要求</li>
</ul>
</li>
<li>查找<ul>
<li>查找jQuery对象内部的元素的子孙/兄弟/父母元素, 并封装成新的jQuery对象返回</li>
<li>children(selector): 子元素</li>
<li>find(selector): 后代元素</li>
<li>preAll(selector): 前的所有兄弟</li>
<li>siblings(selector): 所有兄弟</li>
<li>parent(): 父元素</li>
</ul>
</li>
</ul>
<ol start="3">
<li>文档处理(CUD)模块</li>
</ol>
<ul>
<li>增加<ul>
<li>append() / appendTo(): 插入后部</li>
<li>preppend() / preppendTo(): 插入前部</li>
<li>before(): 插到前面</li>
<li>after(): 插到后面</li>
</ul>
</li>
<li>删除<ul>
<li>remove(): 将自己及内部的孩子都删除</li>
<li>empty(): 掏空(自己还在)</li>
</ul>
</li>
<li>更新<ul>
<li>replaceWith()</li>
</ul>
</li>
</ul>
<ol start="4">
<li>事件模块</li>
</ol>
<ul>
<li>绑定事件<ul>
<li>eventName(function(){})</li>
<li>on(‘eventName’, function(){})</li>
<li>常用: click, mouseenter/mouseleave mouseover/mouseout focus/blur</li>
<li>hover(function(){}, function(){})</li>
</ul>
</li>
<li>解绑事件<ul>
<li>off(‘eventName’)</li>
</ul>
</li>
<li>事件委托<ul>
<li>理解: 将子元素的事件委托给父辈元素处理<ul>
<li>事件监听绑定在父元素上, 但事件发生在子元素上<br>*　事件会冒泡到父元素</li>
<li>但最终调用的事件回调函数的是子元素: event.target</li>
</ul>
</li>
<li>好处<ul>
<li>新增的元素没有事件监听</li>
<li>减少监听的数量(n==&gt;1)</li>
</ul>
</li>
<li>编码<ul>
<li>delegate(selector, ‘eventName’, function(event){}) // 回调函数中的this是子元素</li>
<li>undelegate(‘eventName’)</li>
</ul>
</li>
</ul>
</li>
<li>事件坐标<ul>
<li>event.offsetX: 原点是当前元素左上角</li>
<li>event.clientX: 原点是窗口左上角</li>
<li>event.pageX: 原点是页面左上角</li>
</ul>
</li>
<li>事件相关<ul>
<li>停止事件冒泡: event.stopPropagation()</li>
<li>阻止事件的默认行为: event.preventDefault()</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity变量</title>
    <url>/2022/08/29/unity%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量结构："><a href="#变量结构：" class="headerlink" title="变量结构："></a>变量结构：</h4><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> health <span class="comment">//其他代码文件也可以使用这些信息 会显示在unity界面中（方便频繁调试）</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//开放性  类型  名字</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> health <span class="comment">//局限于当前的脚本中</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h4><span id="more"></span>

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="comment">//整数</span></span><br><span class="line"><span class="built_in">float</span> <span class="comment">//小数</span></span><br><span class="line"><span class="built_in">bool</span> <span class="comment">//布尔值</span></span><br><span class="line"><span class="built_in">string</span> <span class="comment">//字符串</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*应用变量 调用其他脚本的</span></span><br><span class="line"><span class="comment">Unity基于Game Object运作,一种隐形的容器，有着位置朝向尺寸。可以在其中填充各种组件强化功能,脚本也是其中之一。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> Transform somewhere <span class="comment">//存储位置和朝向</span></span><br><span class="line"><span class="keyword">public</span> Color red <span class="comment">//存储颜色</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] numberArray = <span class="keyword">new</span> <span class="built_in">int</span>[] {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//创建一个拥有三个变量整数的数组</span></span><br><span class="line"></span><br><span class="line">numberArray[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//修改数组第一位</span></span><br></pre></td></tr></tbody></table></figure>



<p>文件管理器右键创建一个脚本，双击打开。文件名 PlayeeMove (要一致，否则会出bug)</p>
<p>代码：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment">//上面是引用空间,需要在这引入相应工具箱才能在接下来代码使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayeeMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed; <span class="comment">//声明变量,不去赋值会有相应的默认值不会出bug</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Vector3 playerInput; <span class="comment">//引用变量，它是存储三维空间中物体位置的组件 Vector3 == (x,y,z)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//游戏场景出现后运行</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//游戏每一帧都运行</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>{</span><br><span class="line">        <span class="comment">//时实检测玩家的方向键输入，然后将其转换成（0，0）的坐标值存储起来</span></span><br><span class="line">      playerInput = <span class="keyword">new</span> Vector3(Input.GetAxisRaw(<span class="string">"Horizontal"</span>),</span><br><span class="line">      Input.GetAxisRaw(<span class="string">"Vertical"</span>));  </span><br><span class="line">   </span><br><span class="line">        <span class="comment">//自带的工具箱，代表的是脚本绑定的Game Object的当前的位置</span></span><br><span class="line">        transform.position = playerInput*speed*Time.deltaTime</span><br><span class="line">        +transform.position;</span><br><span class="line">        <span class="comment">//Time.deltaTime代表时间的变量, 加上后可以让角色速度不受帧影响</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2笔记</title>
    <url>/2022/08/28/vue2/</url>
    <content><![CDATA[<h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<span id="more"></span>

<h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol>
<li><p>被用来给元素或子组件注册引用信息（id的替代者）</p>
</li>
<li><p>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</p>
</li>
<li><p>使用方式：</p>
<ol>
<li>打标识：<code>&lt;h1 ref="xxx"&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref="xxx"&gt;&lt;/School&gt;</code></li>
</ol>
</li>
<li><p>获取：<code>this.$refs.xxx</code></p>
<h3 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h3></li>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name="xxx"/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:['name'] </code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:{name:String}</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
 <figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:{</span><br><span class="line">	<span class="attr">name</span>:{</span><br><span class="line">	<span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line">	<span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line">	<span class="attr">default</span>:<span class="string">'老王'</span> <span class="comment">//默认值</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p> 第一步定义混合：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    data(){....},</span><br><span class="line">    methods:{....}</span><br><span class="line">    ....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 第二步使用混入：</p>
<p> ​	全局混入：<code>Vue.mixin(xxx)</code><br> ​	局部混入：<code>mixins:['xxx']	</code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
 <figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) {</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) {...}</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol>
<li><p>组件化编码流程：</p>
<p> ​	(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p> ​	(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p> ​			1).一个组件在用：放在组件自身即可。</p>
<p> ​			2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p> ​	(3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props适用于：</p>
<p> ​	(1).父组件 ==&gt; 子组件 通信</p>
<p> ​	(2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem('key', 'value');</code><br>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li><p><code>xxxxxStorage.getItem('person');</code></p>
<p> ​		该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem('key');</code></p>
<p> ​		该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p> ​		该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu="test"/&gt;</code>  或 <code>&lt;Demo v-on:atguigu="test"/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
 <figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">"demo"</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>){</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">'atguigu'</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit('atguigu',数据)</code>		</p>
</li>
<li><p>解绑自定义事件<code>this.$off('atguigu')</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">	......</span><br><span class="line">	<span class="title function_">beforeCreate</span>(<span class="params"></span>) {</span><br><span class="line">		<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">	},</span><br><span class="line">    ......</span><br><span class="line">}) </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>){</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>){......}</span><br><span class="line">}</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">'xxxx'</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from 'pubsub-js'</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>){</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>){......}</span><br><span class="line">}</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">'xxx'</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>提供数据：<code>pubsub.publish('xxx',数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%"></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;transition name="hello"&gt;</span><br><span class="line">	&lt;h1 v-show="isShow"&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​	在vue.config.js中添加如下配置：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:{</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">"http://localhost:5000"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​	编写vue.config.js配置具体代理规则：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line">	<span class="attr">devServer</span>: {</span><br><span class="line">      <span class="attr">proxy</span>: {</span><br><span class="line">      <span class="string">'/api1'</span>: {<span class="comment">// 匹配所有以 '/api1'开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">'http://localhost:5000'</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: {<span class="string">'^/api1'</span>: <span class="string">''</span>}</span><br><span class="line">      },</span><br><span class="line">      <span class="string">'/api2'</span>: {<span class="comment">// 匹配所有以 '/api2'开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">'http://localhost:5001'</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: {<span class="string">'^/api2'</span>: <span class="string">''</span>}</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>具名插槽：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot="center"&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name="center"&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name="footer"&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template scope="scopeData"&gt;</span><br><span class="line">				&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">				&lt;ul&gt;</span><br><span class="line">					&lt;li v-for="g in scopeData.games" :key="g"&gt;{{g}}&lt;/li&gt;</span><br><span class="line">				&lt;/ul&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template slot-scope="scopeData"&gt;</span><br><span class="line">				&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">				&lt;h4 v-for="g in scopeData.games" :key="g"&gt;{{g}}&lt;/h4&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games="games"&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default {</span><br><span class="line">                name:'Category',</span><br><span class="line">                props:['title'],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() {</span><br><span class="line">                    return {</span><br><span class="line">                        games:['红色警戒','穿越火线','劲舞团','超级玛丽']</span><br><span class="line">                    }</span><br><span class="line">                },</span><br><span class="line">            }</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​		在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​		多个组件需要共享数据时</p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = {}</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = {}</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = {}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>({</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>({</span><br><span class="line">	<span class="attr">el</span>:<span class="string">'#app'</span>,</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">	store</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = {</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line">	<span class="title function_">jia</span>(<span class="params">context,value</span>){</span><br><span class="line">		<span class="comment">// console.log('actions中的jia被调用了',miniStore,value)</span></span><br><span class="line">		context.<span class="title function_">commit</span>(<span class="string">'JIA'</span>,value)</span><br><span class="line">	},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = {</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line">	<span class="title function_">JIA</span>(<span class="params">state,value</span>){</span><br><span class="line">		<span class="comment">// console.log('mutations中的JIA被调用了',state,value)</span></span><br><span class="line">		state.<span class="property">sum</span> += value</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = {</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>({</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch('action中的方法名',数据)</code> 或 <code>$store.commit('mutations中的方法名',数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = {</span><br><span class="line">	<span class="title function_">bigSum</span>(<span class="params">state</span>){</span><br><span class="line">		<span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>({</span><br><span class="line">	......</span><br><span class="line">	getters</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: {</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>({<span class="attr">sum</span>:<span class="string">'sum'</span>,<span class="attr">school</span>:<span class="string">'school'</span>,<span class="attr">subject</span>:<span class="string">'subject'</span>}),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">'sum'</span>,<span class="string">'school'</span>,<span class="string">'subject'</span>]),</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: {</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>({<span class="attr">bigSum</span>:<span class="string">'bigSum'</span>}),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">'bigSum'</span>])</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:{</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>({<span class="attr">incrementOdd</span>:<span class="string">'jiaOdd'</span>,<span class="attr">incrementWait</span>:<span class="string">'jiaWait'</span>})</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">'jiaOdd'</span>,<span class="string">'jiaWait'</span>])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:{</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>({<span class="attr">increment</span>:<span class="string">'JIA'</span>,<span class="attr">decrement</span>:<span class="string">'JIAN'</span>}),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">'JIA'</span>,<span class="string">'JIAN'</span>]),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = {</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:{<span class="attr">x</span>:<span class="number">1</span>},</span><br><span class="line">  <span class="attr">mutations</span>: { ... },</span><br><span class="line">  <span class="attr">actions</span>: { ... },</span><br><span class="line">  <span class="attr">getters</span>: {</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>){</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = {</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:{ ... },</span><br><span class="line">  <span class="attr">mutations</span>: { ... },</span><br><span class="line">  <span class="attr">actions</span>: { ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>({</span><br><span class="line">  <span class="attr">modules</span>: {</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">'countAbout'</span>,[<span class="string">'sum'</span>,<span class="string">'school'</span>,<span class="string">'subject'</span>]),</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">'personAbout/firstPersonName'</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">'countAbout'</span>,[<span class="string">'bigSum'</span>])</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">'personAbout/addPersonWang'</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">'countAbout'</span>,{<span class="attr">incrementOdd</span>:<span class="string">'jiaOdd'</span>,<span class="attr">incrementWait</span>:<span class="string">'jiaWait'</span>})</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">'personAbout/ADD_PERSON'</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">'countAbout'</span>,{<span class="attr">increment</span>:<span class="string">'JIA'</span>,<span class="attr">decrement</span>:<span class="string">'JIAN'</span>}),</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">'../components/About'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">'../components/Home'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>({</span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">path</span>:<span class="string">'/about'</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">		},</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">path</span>:<span class="string">'/home'</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">		}</span><br><span class="line">	]</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;router-link active-class="active" to="/about"&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>指定展示位置</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用children配置项：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">	{</span><br><span class="line">		<span class="attr">path</span>:<span class="string">'/about'</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">	},</span><br><span class="line">	{</span><br><span class="line">		<span class="attr">path</span>:<span class="string">'/home'</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">		<span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">			{</span><br><span class="line">				<span class="attr">path</span>:<span class="string">'news'</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">			},</span><br><span class="line">			{</span><br><span class="line">				<span class="attr">path</span>:<span class="string">'message'</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">			}</span><br><span class="line">		]</span><br><span class="line">	}</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>跳转（要写完整路径）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;router-link to="/home/news"&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to="/home/message/detail?id=666&amp;title=你好"&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to="{</span><br><span class="line">		path:'/home/message/detail',</span><br><span class="line">		query:{</span><br><span class="line">		   id:666,</span><br><span class="line">            title:'你好'</span><br><span class="line">		}</span><br><span class="line">	}"</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="attr">path</span>:<span class="string">'/demo'</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">path</span>:<span class="string">'test'</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				{</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">'hello'</span> <span class="comment">//给路由命名</span></span><br><span class="line">					<span class="attr">path</span>:<span class="string">'welcome'</span>,</span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">				}</span><br><span class="line">			]</span><br><span class="line">		}</span><br><span class="line">	]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>简化跳转：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to="/demo/test/welcome"&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to="{name:'hello'}"&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to="{</span><br><span class="line">		name:'hello',</span><br><span class="line">		query:{</span><br><span class="line">		   id:666,</span><br><span class="line">            title:'你好'</span><br><span class="line">		}</span><br><span class="line">	}"</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
<h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol>
<li><p>配置路由，声明接收params参数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="attr">path</span>:<span class="string">'/home'</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">path</span>:<span class="string">'news'</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">		},</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				{</span><br><span class="line">					<span class="attr">name</span>:<span class="string">'xiangqing'</span>,</span><br><span class="line">					<span class="attr">path</span>:<span class="string">'detail/:id/:title'</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">				}</span><br><span class="line">			]</span><br><span class="line">		}</span><br><span class="line">	]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to="/home/message/detail/666/你好"&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to="{</span><br><span class="line">		name:'xiangqing',</span><br><span class="line">		params:{</span><br><span class="line">		   id:666,</span><br><span class="line">            title:'你好'</span><br><span class="line">		}</span><br><span class="line">	}"</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​	作用：让路由组件更方便的收到参数</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="attr">name</span>:<span class="string">'xiangqing'</span>,</span><br><span class="line">	<span class="attr">path</span>:<span class="string">'detail/:id'</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:{a:900}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:true</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">	<span class="title function_">props</span>(<span class="params">route</span>){</span><br><span class="line">		<span class="keyword">return</span> {</span><br><span class="line">			<span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">			<span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.<router-link>的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>({</span><br><span class="line">	<span class="attr">name</span>:<span class="string">'xiangqing'</span>,</span><br><span class="line">		<span class="attr">params</span>:{</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>({</span><br><span class="line">	<span class="attr">name</span>:<span class="string">'xiangqing'</span>,</span><br><span class="line">		<span class="attr">params</span>:{</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		}</span><br><span class="line">})</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;keep-alive include="News"&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'beforeEach'</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>){ <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">'school'</span>) === <span class="string">'atguigu'</span>){ <span class="comment">//权限控制的具体规则</span></span><br><span class="line">			<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">'暂无权限查看'</span>)</span><br><span class="line">			<span class="comment">// next({name:'guanyu'})</span></span><br><span class="line">		}</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">	}</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'afterEach'</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>){ </span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">'vue_test'</span></span><br><span class="line">	}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>独享守卫:</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>){</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'beforeEnter'</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>){ <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">'school'</span>) === <span class="string">'atguigu'</span>){</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">'暂无权限查看'</span>)</span><br><span class="line">			<span class="comment">// next({name:'guanyu'})</span></span><br><span class="line">		}</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>组件内守卫：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) {</span><br><span class="line">},</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3</title>
    <url>/2022/08/28/vue3/</url>
    <content><![CDATA[<h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px">



<h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li>
<li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>……</p>
</li>
</ul>
<span id="more"></span>

<h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>……</p>
</li>
</ul>
<h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol>
<li><p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>……</li>
</ul>
</li>
<li><p>新的内置组件</p>
<ul>
<li>Fragment </li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li><p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>……</li>
</ul>
</li>
</ol>
<h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left"><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px"></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure>

<h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code> <ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">'count'</span>, {</span><br><span class="line">    get () {}, </span><br><span class="line">    set () {}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul>
<li>实现原理: <ul>
<li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
<li>通过Reflect（反射）:  对源对象的属性进行操作。</li>
<li>MDN文档中描述的Proxy与Reflect：<ul>
<li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, {</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) {</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) {</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) {</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">'tom'</span>   </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul>
<li>从定义数据角度对比：<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> {computed} <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>){</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">'-'</span> + person.<span class="property">lastName</span></span><br><span class="line">    })</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>({</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>){</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">'-'</span> + person.<span class="property">lastName</span></span><br><span class="line">        },</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>){</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">'-'</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'sum变化了'</span>,newValue,oldValue)</span><br><span class="line">},{<span class="attr">immediate</span>:<span class="literal">true</span>})</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'sum或msg变化了'</span>,newValue,oldValue)</span><br><span class="line">}) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'person变化了'</span>,newValue,oldValue)</span><br><span class="line">},{<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>}) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'person的job变化了'</span>,newValue,oldValue)</span><br><span class="line">},{<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>}) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'person的job变化了'</span>,newValue,oldValue)</span><br><span class="line">},{<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>})</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>{</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'person的job变化了'</span>,newValue,oldValue)</span><br><span class="line">},{<span class="attr">deep</span>:<span class="literal">true</span>}) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'watchEffect配置的回调执行了'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px"></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px"></div>





































<p>1</p>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code>&nbsp;==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul>
<li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li><p>语法：<code>const name = toRef(person,'name')</code></p>
</li>
<li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
</ul>
<h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;input type="text" v-model="keyword"&gt;</span><br><span class="line">	&lt;h3&gt;{{keyword}}&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import {ref,customRef} from 'vue'</span><br><span class="line">	export default {</span><br><span class="line">		name:'Demo',</span><br><span class="line">		setup(){</span><br><span class="line">			// let keyword = ref('hello') //使用Vue准备好的内置ref</span><br><span class="line">			//自定义一个myRef</span><br><span class="line">			function myRef(value,delay){</span><br><span class="line">				let timer</span><br><span class="line">				//通过customRef去实现自定义</span><br><span class="line">				return customRef((track,trigger)=&gt;{</span><br><span class="line">					return{</span><br><span class="line">						get(){</span><br><span class="line">							track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">							return value</span><br><span class="line">						},</span><br><span class="line">						set(newValue){</span><br><span class="line">							clearTimeout(timer)</span><br><span class="line">							timer = setTimeout(()=&gt;{</span><br><span class="line">								value = newValue</span><br><span class="line">								trigger() //告诉Vue去更新界面</span><br><span class="line">							},delay)</span><br><span class="line">						}</span><br><span class="line">					}</span><br><span class="line">				})</span><br><span class="line">			}</span><br><span class="line">			let keyword = myRef('hello',500) //使用程序员自定义的ref</span><br><span class="line">			return {</span><br><span class="line">				keyword</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px">

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>){</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>({<span class="attr">name</span>:<span class="string">'奔驰'</span>,<span class="attr">price</span>:<span class="string">'40万'</span>})</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">'car'</span>,car)</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>后代组件中：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>){</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">'car'</span>)</span><br><span class="line">    <span class="keyword">return</span> {car}</span><br><span class="line">	......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
<h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left">
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left"> 
</div>















<h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" style="height:360px">
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" style="height:360px">
</div>













<h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;teleport to="移动位置"&gt;</span><br><span class="line">	&lt;div v-if="isShow" class="mask"&gt;</span><br><span class="line">		&lt;div class="dialog"&gt;</span><br><span class="line">			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">			&lt;button @click="isShow = false"&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> {defineAsyncComponent} <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">'./components/Child.vue'</span>))</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class="app"&gt;</span><br><span class="line">		&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">		&lt;Suspense&gt;</span><br><span class="line">			&lt;template v-slot:default&gt;</span><br><span class="line">				&lt;Child/&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">			&lt;template v-slot:fallback&gt;</span><br><span class="line">				&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Suspense&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">'MyButton'</span>, {</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> ({</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  }),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">'&lt;button @click="count++"&gt;Clicked {{ count }} times.&lt;/button&gt;'</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">'focus'</span>, {</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> {</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> {</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>Vue3.x写法</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> {</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> {</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close="handleComponentEvent"</span><br><span class="line">  v-on:click="handleNativeClickEvent"</span><br><span class="line">/&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default {</span><br><span class="line">    emits: ['close']</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue HelloWord项目笔记</title>
    <url>/2022/11/13/vue%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>安装依赖</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">## 项目技术栈</span><br><span class="line">Vue全家桶：Vue + VueRouter + Vuex + Axios + ElementUI</span><br><span class="line"></span><br><span class="line">## 改为淘宝镜像</span><br><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line">## 或者</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">## 网络请求</span><br><span class="line">npm i --save axios</span><br><span class="line"></span><br><span class="line">## Element</span><br><span class="line">vue add element</span><br><span class="line">官网：https://element.eleme.cn/#/zh-CN</span><br><span class="line"></span><br><span class="line">## 路由</span><br><span class="line">npm install vue-router@3 --save</span><br><span class="line"></span><br><span class="line">## less环境安装</span><br><span class="line">npm i less less-loader --save-dev</span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm i --save express cors mysql</span><br><span class="line">npm i -g concurrently</span><br><span class="line">npm i -g nodemon</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意细节</strong></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6解构赋值</title>
    <url>/2022/08/30/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<ul>
<li><p>ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p>
<ol>
<li><p>数组的结构</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">F4</span> = [<span class="string">'小阳'</span>,<span class="string">'刘能'</span>,<span class="string">'赵四'</span>,<span class="string">'王五'</span>];</span><br><span class="line">    <span class="keyword">let</span> [xiao, liu, zhao, song] = <span class="variable constant_">F4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xiao);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(liu);</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(zhao);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(song);</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
<p>​     </p>
<ol start="2">
<li><p>对象的解构</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">       <span class="keyword">const</span> zhao = {</span><br><span class="line">     </span><br><span class="line">           <span class="attr">name</span>: <span class="string">'某强'</span>,</span><br><span class="line">     </span><br><span class="line">           <span class="attr">age</span>: <span class="string">'不详'</span>,</span><br><span class="line">     </span><br><span class="line">            <span class="attr">xiaopin</span>: <span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">     </span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"我可以打三国杀"</span>);</span><br><span class="line">     </span><br><span class="line">            }</span><br><span class="line">     </span><br><span class="line">         };</span><br><span class="line">     </span><br><span class="line"><span class="keyword">let</span> {name, age, xiaopin} = zhao;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(xiaopin);</span><br><span class="line">              <span class="title function_">xiaopin</span>();</span><br><span class="line">     </span><br><span class="line">             <span class="keyword">let</span> {xiaopin} = zhao;</span><br><span class="line">             <span class="title function_">xiaopin</span>();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
